# -*- indent-tabs-mode: nil -*-
#+startup: hidestars odd

* About

  We are increasingly lost in the sea of information that surrounds us.

  So many valuable things we discover are being routinely lost.
  So many contexts that ought to, never do intersect.
  So many thoughts that could, never come.

  Why?

  Because data entry, interning and recovery is harder that it could be.

  <Name> is a general-purpose mind assistant, that is an attempt to change that.

  A balanced, varied approach to resolve the conflict between extreme ease of use
  and completeness of data being captured.

  It also is supposed to try to be beautiful to the eye.

  This is a design document, accompanied with some code to support it.

* UI tropes

  1. Arrows move
  2. Space pages
  3. Tab cycles state/mode
  4. Escape pops
  5. Return vs. C-Return -- a story of multi-line text input

* (To be) Displayable structures

  - Graphs ::
    - Views :: 
      - Z-axis :: 
        - Classic side view :: 
             Needs root detection, for automatic layout.
      - Arrow-aligned :: 
        - Weighted partitioning :: 

  - Dags ::
    - Views :: 
      - Z-axis :: inherited from Graphs
      - Y-axis :: inherited from Graphs
      - Treeview, list entries, with duplication :: 
      - Treeview, icon grid, with duplication :: 
      - Treeview, space partitioning, ala Lamdu, with duplication :: 
    - Subsetting ::
      - Viewport ::
                   Arrow walker -- for nodes.
                   Iterative refinement -- subsetting and context narrowing.
                   Some kind of a shortcut-based jump language.
                   Bookmarks.
      - Ellipsis ::
                   Zoomable: "everything else in this direction"
                   What cases need it, given a proper Viewport subsetter?

  - Sets ::
    - Views :: 
      - Carousel :: 
      - Grid :: 
      - List :: 
    - Subsetting ::
      - Viewport ::
                   Iterative refinement makes it useful.
                   Arrow walker -- for refinement elements and for.
                   
      - Summary  ::
                   Extracting and exposing set structure.
      - Ellipsis ::
                   Logic summary or an explicit summary.

* Scene composition
*** Phases, quick overview

    - Select                 :: filter stores through =Selector=, yield =Selection=
    - Choose layout engine   :: through defaulting, or also triggered by user
    - Viewport culling       :: engine decides on what can be shown
    - Layout                 :: obtain what is already covered, cover what isn't, compose;  compute scene modifiers
    - Render                 :: ...

*** Phases

    - Select           :: Totality → Selector → Selection
      - Basically, select from available data.  For now, the implementation
        is conceptually irrelevant.  Query optimization might change that.
      - =Selections= split into the following categories, by structure:
        - General graph
        - DAG (directed acyclic graph)
        - Set -- with customisable ordering
          - XXX: ordering not factored in

    - Layout engine choice    :: Selection → EngiPref → Engi
      - =EngiPref= picks a specific =Engi=, compatible with the current
        =Selection= category:
        - defaults to last used
        - size limits for non-partial-capable engines?
        - can be cycled through by a shortcut
      - Engines:
        - Graph, dag, tree:
          - =SideGraph=: graph from aside
          - =DownGraph=: graph, arrow aligned weighted partitioning
        - Dag (duplicates-encoded), tree:
          - =DagList=, list entries
          - =DagGrid=, icon grid
          - =DagSpace=, space partitioning, ala /Lamdu/
        - Set:
          - =Carousel=
          - =Grid=
          - =List=

    - Viewport culling :: Engi → Selection → (Granularity, MinSize) → Viewport → (View, Boundary)
      - XXX: what's the story about half-visible objects?
        - select all intersecting, render more than what is showable?
      - XXX: what's the story about avoidable layout recomputation?
        - *key question*: is it bad?  In case of SideGraph, which *is* about
                          total representation, it's very very bad.
        - *caseanalysis* cacheable total-cost    can-partial partial-composable
          - SideGraph:    yes       very hard     no(?)       no(?)
          - DownGraph:    no        medium-small  yes         yes
          - DagList:      yes       small         yes         yes
          - DagGrid:      yes       medium-small  yes         yes
          - DagSpace:     yes       very hard     yes         yes
          - Carousel:     no        easy          no          no
          - Grid:         yes       easy          yes         yes
          - List:         yes       easy          yes         yes
        - *option*: compute base layout, then viewportcull and localise from base
          - for huge selections this produces unnecessary computation
        - *option*: go with partials and compose them, whenever possible
          - if so, layout needs to be:
            - restartable at arbitrary point
            - splittable and composable
        - *option*: lazy evaluation?
        - NOTE: all obvious caching solutions seem to rely on *Ord*
      - =Granularity= determines, for tree layouts, the maximum depth of
        subdivision, after which abbreviation is engaged
      - =MinSize= limits the minimum element size
      - =Viewport= is specific to =Engi=:
        - SideGraph: layout-global position
        - DownGraph: subroot node
        - DagList:   row offset
        - DagGrid:   row offset
        - DagSpace:  vertical offset (?)
        - Carousel:  current selection
        - Grid:      row offset
        - List:      row offset
      - =View= is direct elements from =Selection=
      - =Boundary= is anchor points to the parts of =Selection= that fall outside the =Viewport=

    - Layout           :: Engi → (View, Boundary) → (Layout, Ephemerals)
      - XXX: =Positions= what are they?
        - scene-specific structure and interpretation?
        - if not, global or screenspace?
        - pixel-based, or [0.0..1.0]?
      - =Ephemerals= are inherently non-persistent, layout-specific things like:
        - element focus visulalisation state:
          - scale change, to indicate foreground/background

    - Change summary   :: 
      - What effect did the last =Selector= change have?  Not always obvious.

    - Render           :: RenderContext → (View, Boundary) → (Layout, Ephemerals) → IO ()

    - Interaction      :: Inputs → (View, Boundary) → Focus → (Granularity, MinSize) → Selector → EngiPref → (Modifiers, Focus, (Granularity, MinSize), Selector, EngiPref)
