# -*- indent-tabs-mode: nil -*-
#+startup: hidestars odd

* About

  We are increasingly lost in the sea of information that surrounds us.

  So many valuable things we discover are being routinely lost.
  So many contexts that ought to, never do intersect.
  So many thoughts that could, never come.

  Why?

  Because data entry, interning and recovery is harder that it could be.

  <Name> is a general-purpose mind assistant, that is an attempt to change that.

  A balanced, varied approach to resolve the conflict between extreme ease of use
  and completeness of data being captured.

  It also is supposed to try to be beautiful to the eye.

  This is a design document, accompanied with some code to support it.

* UI tropes

  1. Arrows move
  2. Space pages
  3. Tab cycles state/mode
  4. Escape pops
  5. Return vs. C-Return -- a story of multi-line text input

* Visualisable qualities

  - Exhaustivity ::
    - Explicit "unknown" remaining
  - Variant-ness ::
    - Simultaneous
    - Per-choice filtering
  - Progression ::
  - Person-zoning ::
  - Distinctions ::
    - Decomposition vs. dependency

* (To be) Displayable structures

  - Graphs ::
    - Views :: 
      - Z-axis :: 
        - Classic side view :: 
             Needs root detection, for automatic layout.
      - Arrow-aligned :: 
        - Weighted partitioning :: 

  - Dags ::
    - Views :: 
      - Z-axis :: inherited from Graphs
      - Y-axis :: inherited from Graphs
      - Treeview, list entries, with duplication :: 
      - Treeview, icon grid, with duplication :: 
      - Treeview, space partitioning, ala Lamdu, with duplication :: 
    - Subsetting ::
      - Viewport ::
                   Arrow walker -- for nodes.
                   Iterative refinement -- subsetting and context narrowing.
                   Some kind of a shortcut-based jump language.
                   Bookmarks.
      - Ellipsis ::
                   Zoomable: "everything else in this direction"
                   What cases need it, given a proper Viewport subsetter?

  - Sets ::
    - Views :: 
      - Carousel :: 
      - Grid :: 
      - List :: 
    - Subsetting ::
      - Viewport ::
                   Iterative refinement makes it useful.
                   Arrow walker -- for refinement elements and for.
                   
      - Summary  ::
                   Extracting and exposing set structure.
      - Ellipsis ::
                   Logic summary or an explicit summary.

* Scene composition
*** Phases, quick overview

    - Select                             :: filter stores through =Selector=, yield =Selection=
    - Layout engine choice               :: through defaulting, or also triggered by user
    - Visibility constraints computation :: engine decides on how much can be shown
    - Viewport positioning               :: engine decides how to place the view around focus
    - Viewport culling                   :: engine decides on what elements fit into the chosen view
    - Layout                             :: obtain what is already covered, cover what isn't, compose;  compute scene modifiers
    - Render                             :: ...

*** Functions, quick overview

    - select         :: Category cat ⇒       Totality → Selector cat → Selection cat
    - elect_engi     :: Category cat ⇒       EngiPref → Maybe (EngiName cat) → EngiName cat
    - erect_engi     :: Engi cat eng ⇒       EngiName cat → eng
    - compute_cull   :: Engi cat eng ⇒       eng → (Granularity, MinSize) → Cull eng
    - place_viewport :: Engi cat eng ⇒       eng → Selection cat → Focus cat → Cull eng → Viewport eng
    - cull_selection :: Engi cat eng ⇒       eng → Selection cat → ViewArgs → Viewport eng → (View cat, Boundary eng
    - layout         :: Engi cat eng ⇒       eng → (View cat, Boundary eng) → (Layout eng, Ephemeral eng)
    - render         :: RenderContext ren ⇒  ren → (View cat, Boundary eng) → (Layout eng, Ephemeral eng) → IO ()
    - interact       :: InputSys is ⇒        is → (View cat, Boundary eng) → Affective → Affective

*** Phases

    - Select :: Totality → Selector → Selection
      - What :: select from Totality
      - =Selections= split into the following categories, by structure:
        - General graph
        - DAG (directed acyclic graph)
        - Set -- with customisable ordering
          - XXX: ordering not factored in
      - Design considerations ::
        - XXX: live-updating selections
          - just carry update frequency for re-selection? (DONE)
          - any kind of policy that would be more.. reactive?
        - XXX: partial selections?
          - what for?
            - for hopelessly large data sets we can limit
              - but a dumb cutoff isn't useful
              - so, a smart, movable cutoff is needed
        - does it make sense for a selector to be non-specific about what it returns?
          - hard to say just yet, we need experience as guide

    - Layout engine choice :: Selection → EngiPref → Engi
      - =EngiPref= picks a specific =Engi=, compatible with the current
        =Selection= category:
        - defaults to last used
        - size limits for non-partial-capable engines?
        - can be cycled through by a shortcut
      - Engines:
        - Graph, dag, tree:
          - =SideGraph=: graph from aside
          - =DownGraph=: graph, arrow aligned weighted partitioning
        - Dag (duplicates-encoded), tree:
          - =DagList=, list entries
          - =DagGrid=, icon grid
          - =DagSpace=, space partitioning, ala /Lamdu/
        - Set:
          - =Carousel=
          - =Grid=
          - =List=
      - Summing up, *fundamentally* we want:
        1. type classes for individual LEs, because it allows for a
           seriously neat organisation of code
        2. multiple LEs associated with a category, because that's how
           the problem domain looks
        3. #1 gives that there isn't a monotype for a LE

    - Visibility constraints computation :: Engi → (Granularity, MinSize) → Cull
      - disconnected from elements -- deals with UI constraints projected onto a
        specific layout engine:
        - for SideGraph and SideDag -- no idea, let practice guide us..
        - for space partitioning it's trivial -- granularity says it all
        - for a Grid and DagGrid -- how many rows and columns
        - for a List -- how many rows
      - updated only rarely -- when the user changes the visualisation parameters

    - Viewport positioning :: Engi → Selection → Focus → Cull → Viewport
      - How do we position a viewport?
        - If we don't have a focus, then it wouldn't make sense to have a viewport
          - Pick a "first" element (maybeHead $ fromList set, f.e.)
        - If we don't have a viewport, generate one containing the focus
        - if we do have a viewport, and the focus is inside -- choice is upon the engine
        - if we the focus is outside, shift the viewport -- how exactly is upon the engine
      - The above exposes following questions:
        - what does "inside a viewport" mean?
        - how can we generate a viewport that is guaranteed to contain a focus?
      - The answer seems to have the shape of a category-specific visibility
        constraint specifier -- a =Cull=.

    - Viewport culling :: Engi → Selection → (Granularity, MinSize) → Viewport → (View, Boundary)
      - XXX: what's the story about half-visible objects?
        - select all intersecting, render more than what is showable?
      - XXX: what's the story about avoidable layout recomputation?
        - *key question*: is it bad?  In case of SideGraph, which *is* about
                          total representation, it's very very bad.
        - *caseanalysis* cacheable total-cost    can-partial partial-composable
          - SideGraph:    yes       very hard     no(?)       no(?)
          - DownGraph:    no        medium-small  yes         yes
          - DagList:      yes       small         yes         yes
          - DagGrid:      yes       medium-small  yes         yes
          - DagSpace:     yes       very hard     yes         yes
          - Carousel:     no        easy          no          no
          - Grid:         yes       easy          yes         yes
          - List:         yes       easy          yes         yes
        - *option*: compute base layout, then viewportcull and localise from base
          - for huge selections this produces unnecessary computation
        - *option*: go with partials and compose them, whenever possible
          - if so, layout needs to be:
            - restartable at arbitrary point
            - splittable and composable
        - *option*: lazy evaluation?
        - NOTE: all obvious caching solutions seem to rely on *Ord*
      - =Granularity= determines, for tree layouts, the maximum depth of
        subdivision, after which abbreviation is engaged
      - =MinSize= limits the minimum element size
      - =Viewport= is specific to =Engi=:
        - SideGraph: layout-global position
        - DownGraph: subroot node
        - DagList:   row offset
        - DagGrid:   row offset
        - DagSpace:  vertical offset (?)
        - Carousel:  current selection
        - Grid:      row offset
        - List:      row offset
      - =View= is direct elements from =Selection=
      - =Boundary= is anchor points to the parts of =Selection= that fall outside the =Viewport=

    - Layout :: Engi → (View, Boundary) → (Layout, Ephemerals)
      - XXX: =Positions= what are they?
        - scene-specific structure and interpretation?
        - if not, global or screenspace?
        - pixel-based, or [0.0..1.0]?
      - =Ephemerals= are inherently non-persistent, layout-specific things like:
        - element focus visulalisation state:
          - scale change, to indicate foreground/background

    - Change summary :: 
      - What effect did the last =Selector= change have?  Not always obvious.

    - Render :: RenderContext → (View, Boundary) → (Layout, Ephemerals) → IO ()

    - Interaction :: Inputs → (View, Boundary) → Focus → (Granularity, MinSize) → Selector → EngiPref → (Modifiers, Focus, (Granularity, MinSize), Selector, EngiPref)
